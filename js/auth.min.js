// === Rotas de retorno ===
const appId = document.querySelector('meta[property=appId]').content;
const urlParams = new URLSearchParams(window.location.search);
const loginRedirect = localStorage.getItem('loginredirect') ?? '';


// === Params -> objeto simples ===
const params = {};
urlParams.forEach((value, key) => {
  params[key] = value;
});

// Detecção robusta de índices (N) existentes: acctN/tokenN/curN
const indices = Object.keys(params)
  .map(k => {
    const m = /^acct(\d+)$/.exec(k);
    return m ? parseInt(m[1], 10) : null;
  })
  .filter(Boolean)
  .sort((a, b) => a - b);

// Helper: pega trio por N (garante coerência)
function getTriple(n) {
  return {
    loginid: params[`acct${n}`],
    token: params[`token${n}`],
    currency: params[`cur${n}`],
  };
}

// === WebSocket Deriv ===
const websocketUrl = `wss://ws.derivws.com/websockets/v3?app_id=${appId}`;
let ws = null;
let reconnectTimeout = null;

function connectWebSocket() {
  ws = new WebSocket(websocketUrl);

  ws.onopen = () => {
    setTimeout(() => {
      ws.close();
    }, 2000)
    // Autoriza com o primeiro token válido da lista (ordem dos índices)
    const first = indices.map(getTriple).find(x => !!x.token);
    if (!first) {
      console.error('Nenhum token* nos parâmetros.');
      return redirectToBot();
    }
    ws.send(JSON.stringify({
      authorize: first.token
    }));
  };

  ws.onmessage = (ev) => {
    const data = JSON.parse(ev.data);
    if (data.msg_type === 'authorize') {
      if (data.authorize) handleAuthorization(data.authorize);
      else if (data.error) {
        alert(data.error.message || 'Erro de autorização.');
        redirectToBot();
      }
    }
  };

  ws.onclose = () => handleWSDown();
  ws.onerror = () => handleWSDown();
}

function handleWSDown() {
  if (!reconnectTimeout) {
    reconnectTimeout = setTimeout(() => {
      reconnectTimeout = null;
      connectWebSocket();
    }, 2000);
  }
}

// === Lógica principal ===
function handleAuthorization(auth) {
  // 1) Linguagem preferida
  if (auth.preferred_language) {
    localStorage.setItem('preferred_language', String(auth.preferred_language).toLowerCase());
  }

  // 2) Descobrir N cujo acctN === auth.loginid -> daí vem o activeToken correto
  const activeIndex = indices.find(n => params[`acct${n}`] === auth.loginid);
  const activeToken = activeIndex ? params[`token${activeIndex}`] : (params.token1 || '');

  localStorage.setItem('active_loginid', auth.loginid);
  localStorage.setItem('activeToken', activeToken);

  // 3) Montar tokenList preservando N: acctN <-> tokenN <-> curN
  const accountList = Array.isArray(auth.account_list) ? auth.account_list : [];
  const byLoginId = {};
  accountList.forEach(acc => {
    byLoginId[acc.loginid] = acc;
  });

  const tokenList = indices
    .map(n => {
      const { loginid, token, currency } = getTriple(n);
      if (!loginid || !token) return null;

      // Base mínima (fallback) se não houver no account_list
      const fallbackInfo = {
        loginid,
        currency: currency || byLoginId[loginid]?.currency || '',
        is_virtual: loginid.startsWith('VRTC') ? 1 : 0,
      };

      // Se é o login autorizado, usar o objeto completo de auth (traz balance etc.)
      const loginInfo =
        loginid === auth.loginid ?
        { ...byLoginId[loginid], ...auth } // merge: info do account_list + authorize atual
        :
        (byLoginId[loginid] || fallbackInfo);

      return {
        accountName: loginid,
        token: token,
        hasRealityCheck: false,
        hasTradeLimitation: false,
        loginInfo,
        lang: params[`lang${n}`] || params.lang || 'en',
      };
    })
    .filter(Boolean);

  localStorage.setItem('tokenList', JSON.stringify(tokenList));

  // =========================================================
  // === NOVO CÓDIGO: Salvar deriv_accounts e deriv_login_id ===
  // =========================================================
  
  const derivAccounts = {};
  
  tokenList.forEach((item, index) => {
    // Pega o primeiro item da lista para salvar no deriv_login_id
    if (index === 0) {
      localStorage.setItem('deriv_login_id', JSON.stringify(item.loginInfo.loginid));
    }

    // Monta o objeto com a chave sendo o loginid (ex: CR4028802)
    derivAccounts[item.loginInfo.loginid] = {
      token: item.token,
      currency: item.loginInfo.currency,
      accountName: item.loginInfo.loginid,
      is_virtual: Number(item.loginInfo.is_virtual), // Garante que seja 0 ou 1 numérico
      loginid: item.loginInfo.loginid,
      // Se tiver saldo (balance) usa, se não, 0. (A API geralmente só manda o saldo da conta ativa no authorize)
      balance: item.loginInfo.balance !== undefined ? Number(item.loginInfo.balance) : 0 
    };
  });

  localStorage.setItem('deriv_accounts', JSON.stringify(derivAccounts));
  // =========================================================

  // 4) Bora pro bot
  redirectToBot();
}

// === Util ===
function redirectToBot() {
  const dest = loginRedirect ? loginRedirect : '/bot';

if (loginRedirect.includes('/trader')) window.location.href = location.href.replace('/auth', '/trader');
if (loginRedirect.includes('/dbot')) window.location.href = location.href.replace('/auth', '/dbot');
if (loginRedirect.includes('/trading')) window.location.href = location.href.replace('/auth', '/trading/auth');
if (loginRedirect.includes('/dtrader')) window.location.href = location.href.replace('/auth', '/dtrader');
if (loginRedirect.includes("/copytrader")) window.location.href = location.href.replace('/auth', '/copytrader')
  else
    window.location.href = dest;
}

// Iniciar
connectWebSocket();
