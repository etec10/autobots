// === Rotas de retorno ===
const appId = document.querySelector('meta[property=appId]').content;
const urlParams = new URLSearchParams(window.location.search);
const loginRedirect = localStorage.getItem('loginredirect') ?? '';

if (loginRedirect.includes('/dbot')) window.location.href = location.href.replace('/auth', '/dbot');
if (loginRedirect.includes('/trading')) window.location.href = location.href.replace('/auth', '/trading/auth');
if (loginRedirect.includes('/dtrader')) window.location.href = location.href.replace('/auth', '/dtrader');
if(loginRedirect.includes("/copytrader")) window.location.href = location.href.replace('/auth','/copytrader')

// === Params → objeto simples ===
const params = {};
urlParams.forEach((value, key) => { params[key] = value; });

// Detecção robusta de índices (N) existentes: acctN/tokenN/curN
const indices = Object.keys(params)
  .map(k => {
    const m = /^acct(\d+)$/.exec(k);
    return m ? parseInt(m[1], 10) : null;
  })
  .filter(Boolean)
  .sort((a, b) => a - b);

// Helper: pega trio por N (garante coerência)
function getTriple(n) {
  return {
    loginid: params[`acct${n}`],
    token: params[`token${n}`],
    currency: params[`cur${n}`],
  };
}

// === WebSocket Deriv ===
const websocketUrl = `wss://ws.derivws.com/websockets/v3?app_id=${appId}`;
let ws = null;
let reconnectTimeout = null;

function connectWebSocket() {
  ws = new WebSocket(websocketUrl);

  ws.onopen = () => {
    // Autoriza com o primeiro token válido da lista (ordem dos índices)
    const first = indices.map(getTriple).find(x => !!x.token);
    if (!first) {
      console.error('Nenhum token* nos parâmetros.');
      return redirectToBot();
    }
    ws.send(JSON.stringify({ authorize: first.token }));
  };

  ws.onmessage = (ev) => {
    const data = JSON.parse(ev.data);
    if (data.msg_type === 'authorize') {
      if (data.authorize) handleAuthorization(data.authorize);
      else if (data.error) {
        alert(data.error.message || 'Erro de autorização.');
        redirectToBot();
      }
    }
  };

  ws.onclose = () => handleWSDown();
  ws.onerror = () => handleWSDown();
}

function handleWSDown() {
  if (!reconnectTimeout) {
    reconnectTimeout = setTimeout(() => {
      reconnectTimeout = null;
      connectWebSocket();
    }, 5000);
  }
}

// === Lógica principal ===
function handleAuthorization(auth) {
  // 1) Linguagem preferida
  if (auth.preferred_language) {
    localStorage.setItem('preferred_language', String(auth.preferred_language).toLowerCase());
  }

  // 2) Descobrir N cujo acctN === auth.loginid → daí vem o activeToken correto
  const activeIndex = indices.find(n => params[`acct${n}`] === auth.loginid);
  const activeToken = activeIndex ? params[`token${activeIndex}`] : (params.token1 || '');

  localStorage.setItem('active_loginid', auth.loginid);
  localStorage.setItem('activeToken', activeToken);

  // 3) Montar tokenList preservando N: acctN ↔ tokenN ↔ curN
  //    Enriquecemos loginInfo com dados do authorize/account_list quando possível.
  const accountList = Array.isArray(auth.account_list) ? auth.account_list : [];
  const byLoginId = {};
  accountList.forEach(acc => { byLoginId[acc.loginid] = acc; });

  const tokenList = indices
    .map(n => {
      const { loginid, token, currency } = getTriple(n);
      if (!loginid || !token) return null;

      // Base mínima (fallback) se não houver no account_list
      const fallbackInfo = {
        loginid,
        currency: currency || byLoginId[loginid]?.currency || '',
        is_virtual: loginid.startsWith('VRTC') ? 1 : 0,
      };

      // Se é o login autorizado, usar o objeto completo de auth (traz balance etc.)
      const loginInfo =
        loginid === auth.loginid
          ? { ...byLoginId[loginid], ...auth } // merge: info do account_list + authorize atual
          : (byLoginId[loginid] || fallbackInfo);

      return {
        accountName: loginid,         // você pode trocar por um label diferente se quiser
        token: token,
        hasRealityCheck: false,
        hasTradeLimitation: false,
        loginInfo,
        lang: params[`lang${n}`] || params.lang || 'en',
      };
    })
    .filter(Boolean);

  localStorage.setItem('tokenList', JSON.stringify(tokenList));

  // 4) Bora pro bot
  redirectToBot();
}

// === Util ===
function redirectToBot() {
  const dest = loginRedirect ? loginRedirect : '/bot';
  window.location.href = dest;
}

// Iniciar
connectWebSocket();
// Se seu fluxo precisa forçar reload (cautela):
// setTimeout(() => location.reload(), 6000);
